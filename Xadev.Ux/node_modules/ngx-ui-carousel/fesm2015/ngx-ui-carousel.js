import { CommonModule } from '@angular/common';
import { Injectable, Component, Input, Output, EventEmitter, HostBinding, ElementRef, Renderer2, Directive, ViewChild, ChangeDetectorRef, ContentChild, HostListener, ContentChildren, defineInjectable, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UiCarouselService {
    constructor() { }
}
UiCarouselService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
UiCarouselService.ctorParameters = () => [];
/** @nocollapse */ UiCarouselService.ngInjectableDef = defineInjectable({ factory: function UiCarouselService_Factory() { return new UiCarouselService(); }, token: UiCarouselService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UILazyloadDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
    }
    /**
     * @return {?}
     */
    load() {
        /** @type {?} */
        const img = this.el.nativeElement;
        if (img.src) {
            return;
        }
        img.src = this.imgUrl;
    }
}
UILazyloadDirective.decorators = [
    { type: Directive, args: [{
                selector: '[libUiLazyLoad]',
                exportAs: 'ui-lazy-load'
            },] }
];
/** @nocollapse */
UILazyloadDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
UILazyloadDirective.propDecorators = {
    imgUrl: [{ type: Input, args: ['imgUrl',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UiCarouselColorConfig {
    /**
     * @param {?=} dotsColor
     * @param {?=} arrowColor
     * @param {?=} itemBackgroundColor
     * @param {?=} printButtonBackgroundColor
     * @param {?=} printButtonFontColor
     */
    constructor(dotsColor, arrowColor, itemBackgroundColor, printButtonBackgroundColor, printButtonFontColor) {
        this.dotsColor = dotsColor ? dotsColor : '#F5F5F5';
        this.arrowColor = arrowColor ? arrowColor : '#F5F5F5';
        this.itemBackgroundColor = itemBackgroundColor ? itemBackgroundColor : '#CCCCCC';
        this.printButtonBackgroundColor = printButtonBackgroundColor ? printButtonBackgroundColor : '#3d3d3d';
        this.printButtonFontColor = printButtonFontColor ? printButtonFontColor : '#FFFFFF';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UiCarouselItemComponent {
    /**
     * @param {?} renderer
     * @param {?} ref
     */
    constructor(renderer, ref) {
        this.renderer = renderer;
        this.ref = ref;
        this.currentPosition = 0;
        this.position = 0;
        this.colorConfig = new UiCarouselColorConfig();
    }
    /**
     * @param {?} position
     * @return {?}
     */
    moveTo(position) {
        this.renderer.setStyle(this.el.nativeElement, 'transform', 'translate3d(' + position + 'px, 0px, 0px)');
        this.renderer.setStyle(this.el.nativeElement, '-webkit-transform', 'translate3d(' + position + 'px, 0px, 0px)');
        this.renderer.setStyle(this.el.nativeElement, '-moz-transform', 'translate3d(' + position + 'px, 0px, 0px)');
        this.renderer.setStyle(this.el.nativeElement, '-o-transform', 'translate3d(' + position + 'px, 0px, 0px)');
        this.renderer.setStyle(this.el.nativeElement, '-ms-transform', 'translate3d(' + position + 'px, 0px, 0px)');
    }
    /**
     * @param {?} distance
     * @return {?}
     */
    moveBy(distance) {
        this.renderer.setStyle(this.el.nativeElement, 'transform', 'translate3d(' + distance + 'px, 0px, 0px)');
        this.renderer.setStyle(this.el.nativeElement, '-webkit-transform', 'translate3d(' + distance + 'px, 0px, 0px)');
        this.renderer.setStyle(this.el.nativeElement, '-moz-transform', 'translate3d(' + distance + 'px, 0px, 0px)');
        this.renderer.setStyle(this.el.nativeElement, '-o-transform', 'translate3d(' + distance + 'px, 0px, 0px)');
        this.renderer.setStyle(this.el.nativeElement, '-ms-transform', 'translate3d(' + distance + 'px, 0px, 0px)');
    }
    /**
     * @param {?} zIndex
     * @return {?}
     */
    setzIndex(zIndex) {
        this.renderer.setStyle(this.el.nativeElement, 'z-index', zIndex);
    }
    /**
     * @return {?}
     */
    disableTransition() {
        this.renderer.setStyle(this.el.nativeElement, 'transition', 'none');
        this.renderer.setStyle(this.el.nativeElement, '-moz-transition', 'none');
        this.renderer.setStyle(this.el.nativeElement, '-webkit-transition', 'none');
        this.renderer.setStyle(this.el.nativeElement, '-o-transition', 'none');
        this.renderer.setStyle(this.el.nativeElement, '-ms-transition', 'none');
    }
    /**
     * @return {?}
     */
    enableTransition() {
        this.renderer.setStyle(this.el.nativeElement, 'transition', 'transform');
        this.renderer.setStyle(this.el.nativeElement, '-moz-transition', 'transform');
        this.renderer.setStyle(this.el.nativeElement, '-webkit-transition', 'transform');
        this.renderer.setStyle(this.el.nativeElement, '-o-transition', 'transform');
        this.renderer.setStyle(this.el.nativeElement, '-ms-transition', 'transform');
        this.renderer.setStyle(this.el.nativeElement, 'transition-duration', this.speed + 'ms');
        this.renderer.setStyle(this.el.nativeElement, '-moz-transition-duration', this.speed + 'ms');
        this.renderer.setStyle(this.el.nativeElement, '-webkit-transition-duration', this.speed + 'ms');
        this.renderer.setStyle(this.el.nativeElement, '-o-transition-duration', this.speed + 'ms');
        this.renderer.setStyle(this.el.nativeElement, '-ms-transition-duration', this.speed + 'ms');
    }
    /**
     * @param {?} duration
     * @return {?}
     */
    fadeOut(duration) {
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        resolve => {
            this.renderer.setStyle(this.el.nativeElement, 'opacity', '0');
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.renderer.setStyle(this.el.nativeElement, 'opacity', '1');
                resolve();
            }), duration);
        }));
    }
    /**
     * @param {?} duration
     * @return {?}
     */
    fadeIn(duration) {
        this.renderer.setStyle(this.el.nativeElement, 'opacity', '0');
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.renderer.setStyle(this.el.nativeElement, 'transition', 'opacity ' + duration + 'ms');
            this.renderer.setStyle(this.el.nativeElement, 'opacity', '1');
        }), 0);
    }
    /**
     * @return {?}
     */
    lazyLoad() {
        this.lazyLoadedImages.forEach((/**
         * @param {?} img
         * @return {?}
         */
        (img) => {
            img.load();
        }));
    }
}
UiCarouselItemComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'ngx-ui-carousel-item',
                template: `
    <div #carouselItem
        [ngStyle]="{'background-color': backgroundColor ? backgroundColor : colorConfig.itemBackgroundColor}"
        class="ui-carousel-item fade" tabindex="-1"
        style="outline: none">
      <ng-content></ng-content>
    </div>
  `,
                styles: [`
  :host {
    display:block!important;
  }

  .ui-carousel-item{
    user-select: none;
    -moz-user-select: none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    -o-user-select: none;
    -ms-user-select: none;
  }

  .transition{
    transition: transform;
    -moz-transition: transform;
    -webkit-transition: transform;
    -o-transition: transform;
    -ms-transition: transform;
    transition-timing-function: ease;
    -moz-transition-timing-function: ease;
    -o-transition-timing-function: ease;
    -ms-transition-timing-function: ease;
  }

  .ui-carousel-item{
    // height: 100%;
    width: 100%;
    position: absolute;
    overflow: hidden;
  }

  .fade{
    opacity: 1;
    -webkit-transition: opacity .5s ease-in;
    -moz-transition: opacity .5s ease-in;
    -ms-transition: opacity .5s ease-in;
    -o-transition: opacity .5s ease-in;
    transition: opacity .5s ease-in;
  }

  .fade-out{
    opacity: 0;
  }
  `]
            }] }
];
/** @nocollapse */
UiCarouselItemComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
UiCarouselItemComponent.propDecorators = {
    el: [{ type: ViewChild, args: ['carouselItem',] }],
    lazyLoadedImages: [{ type: ContentChild, args: [UILazyloadDirective,] }],
    backgroundColor: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UiCarouselComponent {
    /**
     * @param {?} el
     * @param {?} renderer2
     */
    constructor(el, renderer2) {
        this.el = el;
        this.renderer2 = renderer2;
        this.width = '100%';
        this.autoPlay = true;
        this.infinite = true;
        this.fade = false;
        this.isDotsVisible = true;
        this.isArrowsVisible = true;
        this.isPrintButtonVisible = false;
        this.colorConfig = new UiCarouselColorConfig();
        this.onChange = new EventEmitter();
        this.printRequest = new EventEmitter();
        this.currentItemIndex = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.speed = this.speed || 500;
        this.autoPlaySpeed = this.autoPlaySpeed || 1500;
        if (this.autoPlay) {
            this.autoPlayFunction(true);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.height) {
            /** @type {?} */
            let highest = 0;
            this.items.forEach((/**
             * @param {?} itemELement
             * @return {?}
             */
            itemELement => {
                if (itemELement.el.nativeElement.offsetHeight > highest) {
                    highest = itemELement.el.nativeElement.offsetHeight;
                }
            }));
            this.height = `${highest}px`;
        }
        else {
            this.items.forEach((/**
             * @param {?} itemELement
             * @return {?}
             */
            itemELement => {
                itemELement.el.nativeElement.style.overflowY = 'auto';
            }));
        }
        this.items.forEach((/**
         * @param {?} itemELement
         * @return {?}
         */
        itemELement => {
            itemELement.el.nativeElement.style.height = this.height;
        }));
        this.el.nativeElement.style.height = this.height;
        this.el.nativeElement.style.width = this.width;
        if (this.items && this.items.length > 0) {
            this.onChange.emit(0);
            this._width = this.items.first.el.nativeElement.offsetWidth;
        }
        this.firstItemIndex = 0;
        this.lastItemIndex = this.items.length - 1;
        if (!this.fade) {
            this.items.toArray().forEach((/**
             * @param {?} item
             * @param {?} itemIndex
             * @return {?}
             */
            (item, itemIndex) => {
                item.speed = this.speed;
                item.position = this._width * itemIndex;
                item.currentPosition = item.position;
                item.disableTransition();
                item.moveTo(item.position);
            }));
        }
        else {
            this.items.forEach((/**
             * @param {?} item
             * @param {?} index
             * @return {?}
             */
            (item, index) => {
                item.zIndex = this.items.length - index;
                item.setzIndex(item.zIndex);
            }));
        }
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.items.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                item.colorConfig = this.colorConfig;
            }));
        }), 50);
    }
    /**
     * @return {?}
     */
    onPrintClick() {
        /** @type {?} */
        const currentEl = this.items.toArray()[this.currentItemIndex].el;
        this.printRequest.emit(currentEl);
    }
    /**
     * @return {?}
     */
    next() {
        this.slideRight();
    }
    /**
     * @return {?}
     */
    prev() {
        this.slideLeft();
    }
    /**
     * @param {?} index
     * @return {?}
     */
    goTo(index) {
        if (!this.fade) {
            this.slideTo(index);
        }
        else {
            this.fadeTo(index);
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    rotateRightTo(index) {
        while (index !== this.lastItemIndex) {
            this.rotateRight();
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    rotateLeftTo(index) {
        while (index !== this.firstItemIndex) {
            this.rotateLeft();
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    slideTo(index) {
        this.onChange.emit((index + this.items.length) % this.items.length);
        /** @type {?} */
        const steps = this.currentItemIndex - index;
        if (this.infinite) {
            if (steps > 0) {
                this.rotateRightTo(this.currentItemIndex);
            }
            else if (steps < 0) {
                this.rotateLeftTo(this.currentItemIndex);
            }
        }
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.enableTransition();
            this.items.forEach((/**
             * @param {?} item
             * @param {?} i
             * @return {?}
             */
            (item, i) => {
                item.position += this._width * (steps);
                item.currentPosition = item.position;
                item.moveTo(item.position);
            }));
            this.currentItemIndex = (index + this.items.length) % this.items.length;
        }), 50);
    }
    /**
     * @return {?}
     */
    slideLeft() {
        if (!this.isSliding) {
            this.isSliding = true;
            if (!this.infinite) {
                if (this.currentItemIndex === 0) {
                    this.slideToPrevPosition();
                    return;
                }
            }
            this.slideTo(this.currentItemIndex - 1);
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.isSliding = false;
            }), this.speed);
        }
    }
    /**
     * @return {?}
     */
    slideRight() {
        if (!this.isSliding) {
            this.isSliding = true;
            if (!this.infinite) {
                if (this.currentItemIndex === this.items.length - 1) {
                    this.slideToPrevPosition();
                    return;
                }
            }
            this.slideTo(this.currentItemIndex + 1);
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.isSliding = false;
            }), this.speed);
        }
    }
    /**
     * @return {?}
     */
    slideToPrevPosition() {
        this.enableTransition();
        this.items.forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            item.currentPosition = item.position;
            item.moveTo(item.position);
        }));
    }
    /**
     * @return {?}
     */
    disableTransition() {
        this.items.forEach((/**
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        (item, index) => {
            item.disableTransition();
        }));
    }
    /**
     * @return {?}
     */
    enableTransition() {
        this.items.forEach((/**
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        (item, index) => {
            item.enableTransition();
        }));
    }
    /**
     * @param {?} index
     * @return {?}
     */
    getItemByIndex(index) {
        return this.items.find((/**
         * @param {?} item
         * @param {?} i
         * @return {?}
         */
        (item, i) => {
            return i === index;
        }));
    }
    /**
     * @param {?} item
     * @return {?}
     */
    getIndexByItem(item) {
        return this.items.toArray().indexOf(item);
    }
    /**
     * @param {?} n
     * @return {?}
     */
    rotateRightNTimes(n) {
        for (let i = 0; i < n; i++) {
            this.rotateRight();
        }
    }
    /**
     * @param {?} n
     * @return {?}
     */
    rotateLeftNTimes(n) {
        for (let i = 0; i < n; i++) {
            this.rotateLeft();
        }
    }
    /**
     * @return {?}
     */
    rotateRight() {
        /** @type {?} */
        const firstItemRef = this.getItemByIndex(this.firstItemIndex);
        /** @type {?} */
        const lastItemRef = this.getItemByIndex(this.lastItemIndex);
        if (!this.fade) {
            lastItemRef.position = firstItemRef.position - this._width;
            lastItemRef.currentPosition = lastItemRef.position;
            lastItemRef.disableTransition();
            lastItemRef.moveTo(lastItemRef.position);
            this.firstItemIndex = this.lastItemIndex;
            this.lastItemIndex = (this.lastItemIndex - 1 + this.items.length) % this.items.length;
        }
    }
    /**
     * @return {?}
     */
    rotateLeft() {
        /** @type {?} */
        const firstItemRef = this.getItemByIndex(this.firstItemIndex);
        /** @type {?} */
        const lastItemRef = this.getItemByIndex(this.lastItemIndex);
        firstItemRef.position = lastItemRef.position + this._width;
        firstItemRef.currentPosition = firstItemRef.position;
        firstItemRef.disableTransition();
        firstItemRef.moveTo(firstItemRef.position);
        this.lastItemIndex = this.firstItemIndex;
        this.firstItemIndex = (this.lastItemIndex + 1) % this.items.length;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    fadeTo(index) {
        this.onChange.emit(index);
        /** @type {?} */
        const firstItem = this.getItemByIndex(this.currentItemIndex);
        /** @type {?} */
        const targetItem = this.getItemByIndex(index);
        /** @type {?} */
        const highestZIndex = this.items.length;
        targetItem.zIndex = firstItem.zIndex + 1;
        targetItem.setzIndex(targetItem.zIndex);
        targetItem.disableTransition();
        targetItem.fadeIn(this.speed);
        this.currentItemIndex = index;
    }
    /**
     * @return {?}
     */
    fadeRight() {
        /** @type {?} */
        const newIndex = (this.currentItemIndex + 1) % this.items.length;
        this.fadeTo(newIndex);
        this.currentItemIndex = newIndex;
    }
    /**
     * @return {?}
     */
    fadeLeft() {
        /** @type {?} */
        const newIndex = (this.currentItemIndex - 1 + this.items.length) % this.items.length;
        this.fadeTo(newIndex);
        this.currentItemIndex = newIndex;
    }
    // is item first visually and not necessary first in the dom (QueryList)
    /**
     * @param {?} index
     * @return {?}
     */
    isItemFirst(index) {
        return this.firstItemIndex === index;
    }
    // is item last visually and not necessary last in the dom (QueryList)
    /**
     * @param {?} index
     * @return {?}
     */
    isItemLast(index) {
        return this.lastItemIndex === index;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.rePosition();
    }
    /**
     * @return {?}
     */
    rePosition() {
        /** @type {?} */
        const items = this.items.toArray();
        if (this.items && this.items.length > 0) {
            this._width = this.items.first.el.nativeElement.offsetWidth;
        }
        items.sort((/**
         * @param {?} item1
         * @param {?} item2
         * @return {?}
         */
        (item1, item2) => {
            if (item1.position > item2.position) {
                return 1;
            }
            else if (item1.position < item2.position) {
                return -1;
            }
            else {
                return 0;
            }
        }));
        /** @type {?} */
        const currentItem = this.getItemByIndex(this.currentItemIndex);
        /** @type {?} */
        const currentItemIndex = items.indexOf(currentItem);
        for (let i = currentItemIndex; i < items.length + currentItemIndex; i++) {
            /** @type {?} */
            const item = items[(i + items.length) % items.length];
            item.position = ((i + items.length) % items.length - currentItemIndex) * this._width;
            item.disableTransition();
            item.moveTo(item.position);
        }
    }
    /**
     * @param {?} shouldAutoPlay
     * @return {?}
     */
    autoPlayFunction(shouldAutoPlay) {
        if (this.autoPlay) {
            if (shouldAutoPlay) {
                this.interval = setInterval((/**
                 * @return {?}
                 */
                () => {
                    this.next();
                }), this.autoPlaySpeed);
            }
            else {
                clearInterval(this.interval);
            }
        }
    }
}
UiCarouselComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'ngx-ui-carousel',
                template: `
    <div (mouseenter)="(autoPlay)?autoPlayFunction(false):null" (mouseleave)="(autoPlay)?autoPlayFunction(true):null">
      <ng-content></ng-content>
      <dots
        *ngIf="isDotsVisible && items.length > 1"
        [dotsCount]="items.length"
        position="middle"
        [activeDot]="currentItemIndex"
        [colorConfig]="colorConfig"
        (onClick)="goTo($event)"></dots>
      <arrow *ngIf="isArrowsVisible && items.length > 1" dir="left" (onArrowClick)="prev()" [disabled]="false" [colorConfig]="colorConfig"></arrow>
      <arrow *ngIf="isArrowsVisible && items.length > 1" dir="right" (onArrowClick)="next()" [disabled]="false" [colorConfig]="colorConfig"></arrow>
      <print-button
        *ngIf="isPrintButtonVisible"
        (onButtonClick)="onPrintClick()"
        [colorConfig]="colorConfig"
        [disabled]="false"></print-button>
    </div>
  `,
                styles: [`
    :host {
      display: block;
      overflow: hidden;
      position: relative;
    }
  `]
            }] }
];
/** @nocollapse */
UiCarouselComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
UiCarouselComponent.propDecorators = {
    height: [{ type: Input }],
    width: [{ type: Input }],
    speed: [{ type: Input }],
    autoPlay: [{ type: Input }],
    autoPlaySpeed: [{ type: Input }],
    infinite: [{ type: Input }],
    fade: [{ type: Input }],
    isDotsVisible: [{ type: Input }],
    isArrowsVisible: [{ type: Input }],
    isPrintButtonVisible: [{ type: Input }],
    colorConfig: [{ type: Input }],
    onChange: [{ type: Output }],
    printRequest: [{ type: Output }],
    items: [{ type: ContentChildren, args: [UiCarouselItemComponent,] }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ArrowComponent {
    /**
     * @param {?} _el
     * @param {?} _renderer2
     */
    constructor(_el, _renderer2) {
        this._el = _el;
        this._renderer2 = _renderer2;
        this.disabled = true;
        this.onArrowClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get colorConfig() {
        return this._colorConfig;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set colorConfig(value) {
        this._colorConfig = value;
        this.createStyle();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this._colorConfig) {
            this.colorConfig = new UiCarouselColorConfig();
        }
    }
    /**
     * @return {?}
     */
    onClick() {
        if (!this.disabled) {
            this.onArrowClick.emit();
            this.createStyle();
        }
    }
    /**
     * @return {?}
     */
    createStyle() {
        /** @type {?} */
        const styling = `
      .arrow::before, .arrow::after {
        background: ${this.colorConfig.arrowColor};
      }
      `;
        if (this.styleElement) {
            this._renderer2.removeChild(this._renderer2.parentNode(this.styleElement), this.styleElement);
        }
        this.styleElement = this._renderer2.createElement('style');
        this.styleElement.appendChild(this._renderer2.createText(styling));
        this._el.nativeElement.appendChild(this.styleElement);
    }
}
ArrowComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'arrow',
                template: `
    <div #arrow class="arrow" (click)="onClick()"
      [ngClass]="{'left': dir === 'left', 'right': dir === 'right', 'disabled': disabled}">
      <style #shadow-styling [innerHTML]="styling">
      </style>
      </div>
  `,
                styles: [`
  .arrow {
    position: absolute;
    height: 50px;
    width: 30px;
    opacity: .6;
    user-select: none;
    -moz-user-select: none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    -o-user-select: none;
    z-index: 1000;
  }

  .arrow.right {
    right: 15px;
    top: 50%;

    transform: scaleX(-1) translateY(-50%);
    -moz-transform: scaleX(-1) translateY(-50%);
    -o-transform: scaleX(-1) translateY(-50%);
    -webkit-transform: scaleX(-1) translateY(-50%);
    -ms-transform: scaleX(-1) translateY(-50%);
    filter: FlipH;
    -ms-filter: "FlipH";
  }

  .arrow.left{
    left: 15px;
    top: 50%;
    transform: translateY(-50%);
    -moz-transform: translateY(-50%);
    -webkit-transform: translateY(-50%);
    -o-transform: translateY(-50%);
    -ms-transform: translateY(-50%);
  }

  .arrow:hover{
    opacity: .8;
    cursor: pointer;
  }

  .arrow:before{
    content: "";
    height: 3px;
    width: 30px;
    display: block;
    position: absolute;
    top: 14px;
    transform: rotate(-45deg);
    -moz-transform: rotate(-45deg);
    -webkit-transform: rotate(-45deg);
    -o-transform: rotate(-45deg);
    -ms-transform: rotate(-45deg);
  }
  .arrow:after{
    content: "";
    height: 3px;
    width: 30px;
    display: block;
    transform: rotate(45deg);
    -moz-transform: rotate(45deg);
    -webkit-transform: rotate(45deg);
    -o-transform: rotate(45deg);
    -ms-transform: rotate(45deg);
    position: absolute;
    bottom: 14px;
  }
  .arrow.disabled{
    opacity: .4;
  }
  .arrow.disabled:hover{
    opacity: .4;
    cursor: pointer;
  }`]
            }] }
];
/** @nocollapse */
ArrowComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
ArrowComponent.propDecorators = {
    dir: [{ type: Input }],
    disabled: [{ type: Input }],
    colorConfig: [{ type: Input, args: ['colorConfig',] }],
    onArrowClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DotsComponent {
    constructor() {
        this.activeDot = 0;
        this.colorConfig = new UiCarouselColorConfig();
        this.position = 'left';
        this.onClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.numbers = Array(this.dotsCount).fill(0).map((/**
         * @param {?} x
         * @param {?} i
         * @return {?}
         */
        (x, i) => i));
    }
    /**
     * @param {?} index
     * @return {?}
     */
    click(index) {
        this.onClick.emit(index);
        this.activeDot = index;
    }
}
DotsComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'dots',
                template: `
    <div class="dot" [ngStyle]="{'background-color': colorConfig.dotsColor}"
      *ngFor="let number of numbers"
      (click)="click(number)"
      [class.active]="activeDot === number">
    </div>
  `,
                styles: [`
      :host{
          position: absolute;
          display: inline-block;
          z-index: 1000;
      }

      :host(.left){
          bottom: 10px;
          left: 10px;
      }

      :host(.right){
          bottom: 10px;
          right: 10px;
      }

      :host(.middle){
          bottom: 20px;
          left: 50%;
          transform: translateX(-50%);
          -webkit-transform: translateX(-50%);
          -moz-transform: translateX(-50%);
          -o-transform: translateX(-50%);
          -ms-transform: translateX(-50%);
      }

      .dot{
          height: 10px;
          width: 10px;
          border-radius: 5px;
          background: white;
          opacity: .5;
          margin: 0 4px;
          display: inline-block;
      }

      .dot:hover{
          opacity: .9;
          cursor: pointer;
      }

      .dot.active{
          opacity: .9;
      }
  `]
            }] }
];
/** @nocollapse */
DotsComponent.ctorParameters = () => [];
DotsComponent.propDecorators = {
    activeDot: [{ type: Input }],
    dotsCount: [{ type: Input }],
    colorConfig: [{ type: Input }],
    position: [{ type: HostBinding, args: ['class',] }, { type: Input }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ZERO = 0.000000000001;
class SwiperDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.isDown = false;
        this.initialPos = ZERO;
        this.lastPos = ZERO;
        this.swipeDistance = ZERO;
        this.firstSwipeDate = Date.now();
        this.onSwipeRight = new EventEmitter();
        this.onSwipeLeft = new EventEmitter();
        this.onSwipeStart = new EventEmitter();
        this.onSwipeEnd = new EventEmitter();
        this.swipeLeft = new EventEmitter();
        this.swipeRight = new EventEmitter();
    }
    // tslint:disable-next-line:use-life-cycle-interface
    /**
     * @return {?}
     */
    ngOnInit() {
        this.onSwipeEnd.subscribe((/**
         * @return {?}
         */
        () => {
        }));
        this.swipeLeft.subscribe((/**
         * @return {?}
         */
        () => {
            SwiperDirective.canISwipe = false;
            setTimeout((/**
             * @return {?}
             */
            () => {
                SwiperDirective.canISwipe = true;
            }), 350);
        }));
        this.swipeRight.subscribe((/**
         * @return {?}
         */
        () => {
            SwiperDirective.canISwipe = false;
            setTimeout((/**
             * @return {?}
             */
            () => {
                SwiperDirective.canISwipe = true;
            }), 350);
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseDown(event) {
        if (!SwiperDirective.canISwipe) {
            return;
        }
        this.firstSwipeDate = Date.now();
        this.isDown = true;
        this.initialPos = event.clientX;
        this.swipeDistance = 0;
        this.onSwipeStart.emit();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseUp(event) {
        if (!this.isDown) {
            return;
        }
        this.initialPos = this.lastPos = ZERO;
        this.isDown = false;
        if (this.swipeDistance > 100) {
            this.swipeLeft.emit();
        }
        else if (this.swipeDistance < -100) {
            this.swipeRight.emit();
        }
        else {
            this.onSwipeEnd.emit();
        }
        this.swipeDistance = ZERO;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseMove(event) {
        if (this.isDown) {
            /** @type {?} */
            const swipeFrameDistance = event.clientX - this.initialPos - this.lastPos;
            this.swipeDistance += swipeFrameDistance;
            this.lastPos = event.clientX - this.initialPos;
            if (swipeFrameDistance > 0) {
                this.onSwipeLeft.emit(swipeFrameDistance);
            }
            else {
                this.onSwipeRight.emit(swipeFrameDistance);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchMove(event) {
        if (!SwiperDirective.canISwipe) {
            return;
        }
        /** @type {?} */
        const touch = event.touches[0] || event.changedTouches[0];
        /** @type {?} */
        let swipeFrameDistance = touch.clientX - this.initialPos - this.lastPos;
        swipeFrameDistance = swipeFrameDistance < 30 ? swipeFrameDistance : 30;
        this.swipeDistance += swipeFrameDistance;
        this.lastPos = touch.clientX - this.initialPos;
        if (swipeFrameDistance > 0) {
            this.onSwipeLeft.emit(swipeFrameDistance);
        }
        else {
            this.onSwipeRight.emit(swipeFrameDistance);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchStart(event) {
        if (!SwiperDirective.canISwipe) {
            return;
        }
        /** @type {?} */
        const touch = event.touches[0] || event.changedTouches[0];
        this.firstSwipeDate = Date.now();
        this.initialPos = touch.clientX;
        this.swipeDistance = ZERO;
        this.onSwipeStart.emit();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchEnd(event) {
        this.initialPos = this.lastPos = ZERO;
        if (this.swipeDistance > 100) {
            this.swipeLeft.emit();
        }
        else if (this.swipeDistance < -100) {
            this.swipeRight.emit();
        }
        else {
            this.onSwipeEnd.emit();
        }
        this.swipeDistance = ZERO;
    }
}
SwiperDirective.canISwipe = true;
SwiperDirective.decorators = [
    { type: Directive, args: [{
                selector: '[libSwiper]',
                exportAs: 'swiper'
            },] }
];
/** @nocollapse */
SwiperDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
SwiperDirective.propDecorators = {
    onSwipeRight: [{ type: Output }],
    onSwipeLeft: [{ type: Output }],
    onSwipeStart: [{ type: Output }],
    onSwipeEnd: [{ type: Output }],
    swipeLeft: [{ type: Output }],
    swipeRight: [{ type: Output }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
    onMouseUp: [{ type: HostListener, args: ['document:mouseup', ['$event'],] }],
    onMouseMove: [{ type: HostListener, args: ['mousemove', ['$event'],] }],
    onTouchMove: [{ type: HostListener, args: ['touchmove', ['$event'],] }],
    onTouchStart: [{ type: HostListener, args: ['touchstart', ['$event'],] }],
    onTouchEnd: [{ type: HostListener, args: ['touchend', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PrintButtonComponent {
    /**
     * @param {?} _el
     * @param {?} _renderer2
     */
    constructor(_el, _renderer2) {
        this._el = _el;
        this._renderer2 = _renderer2;
        this.disabled = true;
        this.colorConfig = new UiCarouselColorConfig();
        this.onButtonClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    onClick() {
        if (!this.disabled) {
            this.onButtonClick.emit();
        }
    }
}
PrintButtonComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'print-button',
                template: `
    <div #printButton
    class="print-button"
    (click)="onClick()"
    [ngClass]="{'disabled': disabled}"
    [ngStyle]="{'background-color': colorConfig.printButtonBackgroundColor}">
      <span [ngStyle]="{'color': colorConfig.printButtonFontColor}">print</span>
    </div>
  `,
                styles: [`
  .print-button {
    position: absolute;
    height: 30px;
    line-height: 30px;
    text-align: center;
    border-radius: 5px;
    width: 60px;
    opacity: .6;
    user-select: none;
    -moz-user-select: none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    -o-user-select: none;
    z-index: 1000;
    right: 20px;
    top: 20px;
  }

  .print-button.disabled{
    opacity: .4;
  }
  .print-button:hover{
    opacity: .9;
    cursor: pointer;
  }
  .print-button.disabled:hover{
    opacity: .4;
    cursor: pointer;
  }`]
            }] }
];
/** @nocollapse */
PrintButtonComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
PrintButtonComponent.propDecorators = {
    dir: [{ type: Input }],
    disabled: [{ type: Input }],
    colorConfig: [{ type: Input }],
    onButtonClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UiCarouselModule {
}
UiCarouselModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SwiperDirective,
                    UILazyloadDirective,
                    DotsComponent,
                    ArrowComponent,
                    UiCarouselComponent,
                    UiCarouselItemComponent,
                    PrintButtonComponent
                ],
                imports: [
                    CommonModule,
                ],
                exports: [
                    UiCarouselComponent,
                    UiCarouselItemComponent,
                    DotsComponent,
                    ArrowComponent,
                    SwiperDirective,
                    UILazyloadDirective,
                    SwiperDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { UiCarouselService, UiCarouselComponent, ArrowComponent, DotsComponent, UiCarouselItemComponent, UILazyloadDirective, SwiperDirective, UiCarouselModule, UiCarouselColorConfig, PrintButtonComponent };

//# sourceMappingURL=ngx-ui-carousel.js.map